# 字符串传统艺能

## 字符串String的遍历
```java
for (char x : s.toCharArray()) {
    //快速遍历string的方法，速度较快
}
```


## 字符串String的拼接
```java
a = a.concat("sb")
```

# 字符串算法题

## 有效的字母异位词 LC 242
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
当key值确定时，首先考虑以**数组**替代hashmap。

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] temp = new int[26];
        for(char x:s.toCharArray()){
            temp[x - 'a']++;
        }

        for(char x:t.toCharArray()){
            temp[x - 'a']--;
            if( temp[x - 'a'] < 0){
                return false;
            }
        }

        for(int i = 0;i < 26;i++){
            if(temp[i] > 0){
                return false;
            }
        }

        return true;
    }
}
```

## 最长回文串 LC 409
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。
在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

针对每个字符个数计算即可，偶数全算，奇数则减去一。
其中最后一个if判断极为巧妙，同时兼顾了aaac和aaa的情况。

```java
class Solution {
    public int longestPalindrome(String s) {
        int[] temp = new int[52];
        for(char c:s.toCharArray()){
            if (c < 97){
                temp[c - 'A']++;
            }else{
                temp[c - 'a' + 26]++;
            }
        }

        int result = 0;

        for(int i:temp){
            result += (i / 2) * 2;
        }

        if(result < s.length()){
            result++;
        }

        return result;

    }
}
```

## 同构字符串 LC 205
给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

本质上是为了构建一个相同的映射在hash表的key序列。
```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        HashMap<Character , Integer> map = new HashMap<Character , Integer>();
        int[] temp = new int[s.length()];
        int count = 0;

        for(int i = 0;i < s.length();i++){
            if(map.get(s.charAt(i)) == null){
                map.put(s.charAt(i) , count);
                temp[i] = count;
                count++;
            }else{
                temp[i] = map.get(s.charAt(i));
            }
        }

        HashMap<Character , Integer> map2 = new HashMap<Character , Integer>();
        int[] temp2 = new int[s.length()];
        count = 0;

        for(int i = 0;i < t.length();i++){
            if(map2.get(t.charAt(i)) == null){
                map2.put(t.charAt(i) , count);
                temp2[i] = count;
                count++;
            }else{
                temp2[i] = map2.get(t.charAt(i));
            }

            if(temp[i] != temp2[i]){
                return false;
            }
        }

        return true;

    }
}
```
